#!/usr/bin/env Rscript
#USE GTEx blood V8 data, including ambiguous SNPs, remove high correlated SNPs, use TPM+TMM gene expression, add new controls based on HRC maf=0.05 data
#including a method to split large data and use RMPI

# #get all the data
#generated by read_GTEx_EC.R
#snp,snppos,rownames:1:1234_C_T
#to get the results based on 1se rule
#use the code from James 4/18/2020

#salloc -t 6-1 --constraint=gizmok -n 21 mpirun -n 1 R --interactive
#salloc -t 6-1 --constraint=gizmok -n 21 mpirun -n 1 Rscript ./prediction_michigan_model6_GTexV8_TPM_addcontrols_hrc_maf005.R &

args = commandArgs(trailingOnly=TRUE)
rdata=paste0("/fh/fast/dai_j/BEACON/BEACON_GRANT/result/",args[1])
if (! file.exists(rdata))
{
  stop("snpdata does not exist!")
}
load(rdata)

#load data
#load("/fh/fast/dai_j/BEACON/BEACON_GRANT/result/GTExV8blooddata_ambiguous_TPM_addcontrols_HRC_maf001_for_prediction.RData")

prefix=args[2]
if (!exists("prefix"))
{
  stop("prefix is not given!")
}
#prefix="dist500K_GTEx_blood_HRC"

#regular TWAS-step 1----------------
# removehighcorr=function(dat=0,corcutoff=0.9)
# {
#   tmp <- cor(dat)
#   tmp[upper.tri(tmp)] <- 0
#   diag(tmp) <- 0
#   datnew <- dat[,!apply(tmp,2,function(x) any(abs(x) > corcutoff))]
#   return(datnew)
# }
removehighcorr=function(dat=0,corcutoff=0.9)
{
  tmp <- cor(dat)
  tmp[upper.tri(tmp)] <- 0
  diag(tmp) <- 0
  ## first remove redundant SNPs corr=1 ##
  datnew <- dat[,!apply(tmp,2,function(x) any(abs(x) >= 1))]
  ## next remove high correlation SNPs but not exactly same ##
  tmp <- cor(datnew)
  tmp[upper.tri(tmp)] <- 0
  diag(tmp) <- 0
  dlist <- (1:ncol(datnew))[apply(tmp,2,function(x) any(abs(x) >= corcutoff))]
  rlist <- (1:ncol(datnew))[!apply(tmp,2,function(x) any(abs(x) >= corcutoff))]
  clist <- NULL
  for (l in dlist) {
    clist <- c(clist, which(abs(tmp[,l])>=corcutoff))
  } 
  
  ## this is to make sure every deleted SNP has one tagSNP retained
  
  l<-1
  while (l<=length(dlist)) {
    ll <- dlist[l]
    tt <- which(abs(tmp[,ll])>=corcutoff)
    if (sum(tt %in% rlist)==0) {
      tcount <- rep(0,length(tt))
      for (k in 1:length(tt)) {
        tcount[k] <- sum(clist==tt[k])
      }
      rlist <- c(rlist,tt[which.max(tcount)])
      dlist <- dlist[-which(dlist==tt[which.max(tcount)])]
    } 
    l <- l+1
  } 
  rlist <- rlist[order(rlist)]
  datnew <- datnew[,rlist]
  return(datnew)
}

#predicted geneexp using crossvalidation
fitted_cv=function(Xsel,covariateall,Y,ncv=5)
{
  Xall=data.matrix(cbind(Xsel,covariateall))
  maxnumvar=floor(length(Y)*(1-1/ncv))
  if (ncol(Xall)>maxnumvar-1) #number of covariates is greater than sample size, select subset of covariates
  {
    lmfit1=lm(Y~Xall)
    lmcoeff1=summary(lmfit1)$coefficients
    rownames(lmcoeff1)=gsub("Xall","",rownames(lmcoeff1))
    lmleftsnp1=rownames(lmcoeff1)[rownames(lmcoeff1) %in% colnames(Xsel)] 
    idx1=match(lmleftsnp1,rownames(lmcoeff1))
    lmleftsnp1=lmleftsnp1[order(abs(lmcoeff1[idx1,1]),decreasing = T)]
    idx1=match(lmleftsnp1,colnames(Xsel))
    Xsel=Xsel[,idx1]
    Xsel=Xsel[,1:(maxnumvar-ncol(covariateall)-1)]
    
    Xall=data.matrix(cbind(Xsel,covariateall))
  }
  
  fitted1=rep(0,length(Y))
  set.seed(10000)
  permutidx=sample(1:length(Y))
  idxs=as.integer(seq(1,length(Y)+1,length.out = ncv+1)) #boundary points of cv segments
  
  for (ii in 1:ncv)
  {
    idx_predict=rep(F,length(Y))
    idx_predict[idxs[ii]:(idxs[ii+1]-1)]=T
    trainfm=lm(Y[permutidx[!idx_predict]]~Xall[permutidx[!idx_predict],])
    traincoeff=summary(trainfm)$coefficients
    rownames(traincoeff)=gsub("Xall[permutidx[!idx_predict], ]","",rownames(traincoeff),fixed = T)
    trainleftsnps=rownames(traincoeff)[rownames(traincoeff) %in% colnames(Xsel)]
    numvar=length(trainleftsnps)
    idx1=match(trainleftsnps,colnames(Xsel))
    Xsel1=Xsel[,idx1]
    if (numvar==1)
    {
      Xsel1=matrix(Xsel1,ncol=1)
      colnames(Xsel1)=trainleftsnps
    }
    fitted1[permutidx[idx_predict]]=rep(traincoeff[1,1],sum(idx_predict)) #intercept term
    idx1=match(trainleftsnps,rownames(traincoeff))
    if (numvar>0) #to add each selected snp term
    {
      for (j in 1:numvar)
      {
        fitted1[permutidx[idx_predict]]=fitted1[permutidx[idx_predict]]+Xsel1[permutidx[idx_predict],j]*traincoeff[idx1[j],1]
      }
    }
  }
  return(fitted1)
}

#new minimum rule,run 100 cvfit,distcutoff:dist to pick cis SNPs, corcutoff:to remove high correlated SNPs
# So I went through diagnosis: here are my choices
# 
# Use the last version of datasets with ambiguous data and : TPM+TMM+standardize
# Include covariates into model selection,
# Use standardize=T in glmnet
# Still do 100 CV to stabilize the selection
# Use correlation filtering threshold 0.9
compute_cor_arow=function(i,ncv=10,distcutoff=5e5,corcutoff=0.9)
{
  
  Y=unlist(phenotype[i,]) #geneexp
  r2=NA
  glmflag=0 #if glm selected variables
  tmp=distance(gr_snp,gr_pos[i])
  idx=which(tmp<distcutoff)
  tmp=rowSums(data.matrix(snp[idx,]))
  idx=idx[tmp!=0] #remove all 0 genotypes
  numlowcorsnp=0 #number of SNP after removing high correlation SNPs
  numvar=0 #number of snp selected by glmnet
  numsnp=NA
  selectedsnps=NA
  selectedsnps_coeff=NA
  numlowcorsnp=NA
  
  if (length(idx)>1)
  {
    tmp=quantile(Y,probs=c(0.15,0.85))
    if (tmp[1]==tmp[2]) Y=Y+rnorm(length(Y),0,min(abs(Y))/1e6)
    
    #too many highly correlated SNPs are included for glmnet
    X1=t(snp[idx,])
    ucor <- matrix(0,ncol(X1),2)
    for (l in 1:ncol(X1)){
      ucov<- data.matrix(cbind(X1[,l],covariate))
      ufit <- lm(Y~ucov)
      ucor[l,1] <- summary(ufit)$coef[2,4]
      ucor[l,2] <- cor(Y,X1[,l])
    } 
    
    #hist(ucor[,1])
    pcor <- ucor[,1]
    ## I order the snps based on their correlation with gene expression, first delete those low correlation-with-gene SNPs
    X1 <- X1[,order(pcor,decreasing=T)]
    X <- removehighcorr(X1,corcutoff)
    if (class(X)[1]=="numeric") #only 1 snp left
    {
      X=matrix(X,nrow=length(X),ncol=1)
    }
    numlowcorsnp=ncol(X)
    #hist(ucor[colnames(X1)%in% colnames(X),1])
    #hist(ucor[colnames(X1)%in% colnames(X),2])
    #dim(X)
    
    Xall=data.matrix(cbind(X,covariate))
    
    covariateall=covariate
    
    penalty=rep(1,ncol(Xall))
    #penalty[(ncol(X)+1):length(penalty)]=0 #force the covariates to be included in the model
    set.seed(i+10000)
    cvfit=tryCatch(
      {
        ### I change alpha to 0.5 for better variable selection when highly correlated features
        cv.glmnet(data.matrix(Xall),Y,nfolds=10, penalty.factor=penalty,alpha=0.5,standardize=T)
      },
      error=function(e)
      {
        return(F)
      }
    )
    #plot(cvfit)
    if (is.list(cvfit))
    {
      ## do 100 times cv.glmnet and take average for cverr
      ## the number of cvfit$lambda may be less than 100 sometimes even you specified 100
      cverr <- matrix(NA,length(cvfit$lambda),100)
      rownames(cverr)=cvfit$lambda
      for (l in 1:ncol(cverr)) {
        set.seed(l+100)
        fit=tryCatch(
          {
            ### I change alpha to 0.5 for better variable selection when highly correlated features
            cv.glmnet(data.matrix(Xall),Y,nfolds=10, penalty.factor=penalty,alpha=0.5,standardize=T)
          },
          error=function(e)
          {
            return(F)
          }
        )
        if (is.list(fit)) #Error in predmat[which, seq(nlami)] = preds : replacement has length zero
        {
          #fit <- cv.glmnet(data.matrix(Xall),Y,nlambda=100,nfolds=10, penalty.factor=penalty,alpha=0.5)
          alllambda=intersect(cvfit$lambda,fit$lambda)
          idx1=match(alllambda,cvfit$lambda)
          idx2=match(alllambda,fit$lambda)
          cverr[idx1,l] <- fit$cvm[idx2]
        }
      }
      merr <- apply(cverr,1,mean,na.rm=T)
      #plot(log(cvfit$lambda),merr)
      lambda.best <- cvfit$lambda[which.min(merr)]
      #fit=glmnet(as.matrix(Xall),Y,nlambda = 100, penalty.factor=penalty,alpha=0.5,standardize=T)
      glmcoeff=as.matrix(coef(cvfit,s=lambda.best))
      #sum(rownames(glmcoeff)[glmcoeff[,1]!=0] %in% colnames(X))
      #glmcoeff[glmcoeff[,1]!=0 & rownames(glmcoeff) %in% colnames(X),1]
      #the selected covariate
      selectcovariate=rownames(glmcoeff)[!rownames(glmcoeff) %in% colnames(X) & glmcoeff[,1]!=0]
      selectcovariate=selectcovariate[selectcovariate!="(Intercept)"]
      selectcovariate=covariateall[,colnames(covariateall) %in% selectcovariate,drop=F]
      glmleftsnp=rownames(glmcoeff)[rownames(glmcoeff) %in% colnames(X) & glmcoeff[,1]!=0] #snps left in glm model
      idx1=match(glmleftsnp,rownames(glmcoeff))
      glmleftsnp=glmleftsnp[order(abs(glmcoeff[idx1,1]),decreasing = T)] #order selected snp by effect size
      numvar=length(glmleftsnp)
      if (numvar>0)
      {
        idx1=match(glmleftsnp,colnames(X))
        Xsel=X[,idx1]
        if (numvar>1) #check if number of covariate is greater than sample size
        {
          nummaxvar=min(nrow(X)-ncol(selectcovariate)-1,numvar)
          numvar=nummaxvar
          Xsel=Xsel[,1:nummaxvar]
        }
        if (numvar==1) #keep Xsel as in matrix form
        {
          Xsel=matrix(Xsel,ncol=1)
          colnames(Xsel)=glmleftsnp
        }
        Xall1=data.matrix(cbind(Xsel,selectcovariate))
        #colnames(Xall1)[1:numvar]=glmleftsnp #deal with when only 1 snp is selected
        fit1=lm(Y~Xall1) # to remove snps with NA coefficient due to colinearity
        #summary(fit1)$r.squared
        lmcoeff=summary(fit1)$coefficients
        #align up coeff with Xsel
        rownames(lmcoeff)=gsub("Xall1","",rownames(lmcoeff))
        lmleftsnp=rownames(lmcoeff)[rownames(lmcoeff) %in% colnames(Xsel)] 
        numvar=length(lmleftsnp)
        if (numvar>0)
        {
          glmflag=1
          idx1=match(lmleftsnp,rownames(lmcoeff))
          selectedsnps=paste0(rownames(lmcoeff)[idx1],collapse = "|")
          selectedsnps_coeff=paste0(lmcoeff[idx1,1],collapse = "|")
          idx1=match(lmleftsnp,colnames(Xsel))
          Xsel=Xsel[,idx1]
          if (numvar==1)
          {
            Xsel=matrix(Xsel,ncol=1)
            colnames(Xsel)=lmleftsnp
          }
          fitted=fitted_cv(Xsel,selectcovariate,Y,ncv=ncv)
          r2=cor(fitted,Y)^2
          #tmp=abs(cor(Y,Xsel))
          #hist(tmp,main=paste0(numvar," snps"),xlab="correlation between snps and expr")
        }
      }
    }
  }
  return(list(r2=r2,glmflag=glmflag,numvar=numvar,numsnp=length(idx),selectedsnps=selectedsnps,selectedsnps_coeff=selectedsnps_coeff,
              numlowcorsnp=numlowcorsnp))
}

# compute_cor_arow_fusion=function(i,ncv=10,distcutoff=5e5)
# {
#   
#   Y=unlist(phenotype[i,]) #geneexp
#   r2=NA
#   glmflag=0 #if glm selected variables
#   tmp=distance(gr_snp,gr_pos[i])
#   idx=which(tmp<distcutoff)
#   tmp=rowSums(data.matrix(snp[idx,]))
#   idx=idx[tmp!=0] #remove all 0 genotypes
#   numvar=0 #number of snp selected by glmnet
#   selectedsnps=NA
#   selectedsnps_coeff=NA
#   p_gender=NA
#   p_age=NA
#   tmp=quantile(Y,probs=c(0.15,0.85))
#   if (tmp[1]==tmp[2]) Y=Y+rnorm(length(Y),0,min(abs(Y))/1e6)
#   if (length(idx)>1)
#   {
#     #too many highly correlated SNPs are included for glmnet
#     X1=t(snp[idx,])
#     ucor <- matrix(0,ncol(X1),2)
#     for (l in 1:ncol(X1)){
#       ucov<- data.matrix(cbind(X1[,l],covariate))
#       ufit <- lm(Y~ucov)
#       ucor[l,1] <- summary(ufit)$coef[2,4]
#       ucor[l,2] <- cor(Y,X1[,l])
#     } 
#     
#     #hist(ucor[,1])
#     pcor <- ucor[,1]
#     ## I order the snps based on their correlation with gene expression, first delete those low correlation-with-gene SNPs
#     X1 <- X1[,order(pcor,decreasing=T)]
#     X <- removehighcorr(X1,0.8)
#     if (class(X)=="numeric") #only 1 snp left
#     {
#       X=matrix(X,nrow=length(X),ncol=1)
#     }
#     
#     #fusion add this:----
#     X2=scale(X)
#     #regress covariates out of the genotypes as well (this is more accurate but slower)
#     for (i in 1:ncol(X))
#     {
#       dat=data.frame(y=X[,i],covariate)
#       X2[,i]= summary(lm(y~.,data= dat ))$resid
#     }
#     X=scale(X2)
#     #remove variance in phenotype explained by covariates
#     dat=data.frame(y=Y,covariate)
#     Y2 = summary(lm(y~., data=dat ))$resid
#     Y=scale(Y2)
#     #end adding
#     
#     #Xall=data.matrix(cbind(X,covariate))
#     
#     #covariateall=covariate
#     
#     #penalty=rep(1,ncol(Xall))
#     #penalty[(ncol(X)+1):length(penalty)]=0 #force the covariates to be included in the model
#     set.seed(i+10000)
#     cvfit=tryCatch(
#       {
#         ### I change alpha to 0.5 for better variable selection when highly correlated features
#         cv.glmnet(data.matrix(X),Y,nlambda=100,nfolds=10,alpha=0.5,standardize=T)
#       },
#       error=function(e)
#       {
#         return(F)
#       }
#     )
#     
#     if (is.list(cvfit))
#     {
#       ## do 100 times cv.glmnet and take average for cverr
#       ## the number of cvfit$lambda may be less than 100 sometimes even you specified 100
#       cverr <- matrix(NA,length(cvfit$lambda),100)
#       rownames(cverr)=cvfit$lambda
#       for (l in 1:100) {
#         set.seed(l+100)
#         fit=tryCatch(
#           {
#             ### I change alpha to 0.5 for better variable selection when highly correlated features
#             cv.glmnet(data.matrix(X),Y,nlambda=100,nfolds=10,alpha=0.5,standardize=T)
#           },
#           error=function(e)
#           {
#             return(F)
#           }
#         )
#         if (is.list(fit)) #Error in predmat[which, seq(nlami)] = preds : replacement has length zero
#         {
#           #fit <- cv.glmnet(data.matrix(Xall),Y,nlambda=100,nfolds=10, penalty.factor=penalty,alpha=0.5)
#           alllambda=intersect(cvfit$lambda,fit$lambda)
#           idx1=match(alllambda,cvfit$lambda)
#           idx2=match(alllambda,fit$lambda)
#           cverr[idx1,l] <- fit$cvm[idx2]
#         }
#       }
#       merr <- apply(cverr,1,mean,na.rm=T)
#       #plot(log(cvfit$lambda),merr)
#       lambda.best <- cvfit$lambda[which.min(merr)]
#       #fit=glmnet(as.matrix(Xall),Y,nlambda = 100, penalty.factor=penalty,alpha=0.5)
#       glmcoeff=as.matrix(coef(fit,s=lambda.best))
#       #sum(rownames(glmcoeff)[glmcoeff[,1]!=0] %in% colnames(X))
#       #glmcoeff[glmcoeff[,1]!=0 & rownames(glmcoeff) %in% colnames(X),1]
#       glmleftsnp=rownames(glmcoeff)[rownames(glmcoeff) %in% colnames(X) & glmcoeff[,1]!=0] #snps left in glm model
#       idx1=match(glmleftsnp,rownames(glmcoeff))
#       glmleftsnp=glmleftsnp[order(abs(glmcoeff[idx1,1]),decreasing = T)] #order selected snp by effect size
#       numvar=length(glmleftsnp)
#       if (numvar>0)
#       {
#         idx1=match(glmleftsnp,colnames(X))
#         Xsel=X[,idx1]
#         if (numvar>1) #check if number of covariate is greater than sample size
#         {
#           nummaxvar=min(nrow(X)-ncol(covariateall)-1,numvar)
#           numvar=nummaxvar
#           Xsel=Xsel[,1:nummaxvar]
#         }
#         if (numvar==1) #keep Xsel as in matrix form
#         {
#           Xsel=matrix(Xsel,ncol=1)
#           colnames(Xsel)=glmleftsnp
#         }
#         Xall1=data.matrix(cbind(Xsel,covariateall))
#         #colnames(Xall1)[1:numvar]=glmleftsnp #deal with when only 1 snp is selected
#         fit1=lm(Y~Xall1) # to remove snps with NA coefficient due to colinearity
#         #summary(fit1)$r.squared
#         lmcoeff=summary(fit1)$coefficients
#         #align up coeff with Xsel
#         rownames(lmcoeff)=gsub("Xall1","",rownames(lmcoeff))
#         if (sum(rownames(lmcoeff)=="age")>0) p_age=lmcoeff[which(rownames(lmcoeff)=="age"),4]
#         #p_disease=lmcoeff[which(rownames(lmcoeff)=="disease"),4]
#         if (sum(rownames(lmcoeff)=="gender")>0) p_gender=lmcoeff[which(rownames(lmcoeff)=="gender"),4]
#         lmleftsnp=rownames(lmcoeff)[rownames(lmcoeff) %in% colnames(Xsel)] 
#         numvar=length(lmleftsnp)
#         if (numvar>0)
#         {
#           glmflag=1
#           idx1=match(lmleftsnp,rownames(lmcoeff))
#           selectedsnps=paste0(rownames(lmcoeff)[idx1],collapse = "|")
#           selectedsnps_coeff=paste0(lmcoeff[idx1,1],collapse = "|")
#           idx1=match(lmleftsnp,colnames(Xsel))
#           Xsel=Xsel[,idx1]
#           if (numvar==1)
#           {
#             Xsel=matrix(Xsel,ncol=1)
#             colnames(Xsel)=lmleftsnp
#           }
#           fitted=fitted_cv(Xsel,covariateall,Y,ncv=ncv)
#           r2=cor(fitted,Y)^2
#           tmp=abs(cor(Y,Xsel))
#           hist(tmp,main=paste0(numvar," snps"),xlab="correlation between snps and expr")
#         }
#       }
#     }
#   }
#   return(list(r2=r2,glmflag=glmflag,numvar=numvar,numsnp=length(idx),selectedsnps=selectedsnps,selectedsnps_coeff=selectedsnps_coeff,
#               p_age=p_age,p_gender=p_gender))
# }


library(glmnet)
library(GenomicRanges)
snppos$chr[snppos$chr==23]="X"
phenotypepos$chr[phenotypepos$chr==23]="X"
gr_allsnp=gr_snp=GRanges(seqnames = snppos$chr,ranges=IRanges(start=snppos$pos,width = 1)) #SNP
gr_allpos=gr_pos=GRanges(seqnames = phenotypepos$chr,ranges=IRanges(start=phenotypepos$s1,end=phenotypepos$s2)) #geneexp
allsnp=snp
allsnppos=snppos
allphenotype=phenotype
allphenotypepos=phenotypepos


#compute

Sys.time()

outfolder=paste0("/fh/fast/dai_j/BEACON/BEACON_GRANT/result/",prefix)
if (!dir.exists(outfolder)) dir.create(outfolder)
sink(paste0(outfolder,"/TWAS.log")) #TWAS1.log association analysis including 6 pcs
msgcon <- file(paste0(outfolder,"/TWAS_message.log"), open = "w")
sink(msgcon,type="message")
# #KXD1
# gene="UBAC1"
# gene="S100A11"
# gene="KXD1"
# gene="LDAH"
# test=compute_cor_arow(i=which(rownames(phenotype)==gene),ncv=10,distcutoff = 5e5,corcutoff = 0.99)
# test1=compute_cor_arow(i=which(rownames(phenotype)==gene),ncv=10,distcutoff = 5e5,corcutoff = 0.9)
# length(intersect(unlist(strsplit(test$selectedsnps,"|",fixed = T)),unlist(strsplit(test1$selectedsnps,"|",fixed = T))))
# #test2=compute_cor_arow(i=which(rownames(phenotype)==gene),ncv=10,distcutoff = 5e5,corcutoff = 0.5)
# 
# Sys.time()
# #parallel
#salloc --constraint=gizmok -t 6-1  -n 21 mpirun -n 1 R --interactive
library(Rmpi)
njobs=mpi.universe.size() - 1
print(njobs)
mpi.spawn.Rslaves(nslaves=njobs,needlog = F)

firststep=F
if (firststep==T)
{
  mpi.bcast.cmd(library(GenomicRanges))

  mpi.bcast.cmd(library(glmnet))

  mpi.bcast.Robj2slave(compute_cor_arow)

  mpi.bcast.Robj2slave(fitted_cv)

  mpi.bcast.Robj2slave(removehighcorr)

  mpi.bcast.Robj2slave(covariate) 

  #snp in a chr is too big to read into slaves, split snp into 5 chunks
  # divide_snp5=function(snpdat=snp,idx=1)
  # {
  #   idxs=seq(1,nrow(snpdat),by=as.integer(nrow(snpdat)/5))
  #   idxs[length(idxs)]=nrow(snpdat)+1
  #   
  #   snpdat1=snpdat[idxs[idx]:(idxs[idx+1]-1),]
  #   return(snpdat1)
  # }
  

  divide_snp_2list=function(snpdat=snp)
  {
    idxs=seq(1,nrow(snpdat),by=as.integer(nrow(snpdat)/5))
    idxs[length(idxs)]=nrow(snpdat)+1
    snplist=list()
    for (i in 1:(length(idxs)-1))
    {
      snplist[[i]]=snpdat[idxs[i]:(idxs[i+1]-1),]
    }
    return(snplist)
  }

  rbind_snplist=function(ii)
  {
    snp=NULL
    for (i in 1:ii)
    {
       #snp=rbind(snp,snplist[[i]])
      tmpsnp=get(paste0("snp",i)) 
      snp=rbind(snp,tmpsnp)
    }
    return(snp)
  }
  
  #run on each chr
  mpi_compute_cor=function(ncv=10,distcutoff=5e5,corcutoff=0.9)
  {
    res=NULL
    n=njobs
    startchr=1
    #keep from what we had
    if (file.exists(paste0(outfolder,"/TWAStmpresult.RData")))
    {
      load(paste0(outfolder,"/TWAStmpresult.RData"))
      startchr=chr+1
    }
    for (chr in startchr:22)
    {
      print(Sys.time())
      print(paste0(chr,"---"))
      idx=which(allphenotypepos$chr==chr)
      phenotype=allphenotype[idx,]
      phenotypepos=allphenotypepos[idx,]
      gr_pos=gr_allpos[idx]
      idx=which(allsnppos$chr==chr)
      snp=allsnp[idx,]
      
      #works, but this is too complicated
      # snp1=divide_snp5(snpdat=snp,idx=1)
      # snp2=divide_snp5(snpdat=snp,idx=2)
      # snp3=divide_snp5(snpdat=snp,idx=3)
      # snp4=divide_snp5(snpdat=snp,idx=4)
      # snp5=divide_snp5(snpdat=snp,idx=5)
      # mpi.bcast.Robj2slave(snp1)
      # mpi.bcast.Robj2slave(snp2)
      # mpi.bcast.Robj2slave(snp3)
      # mpi.bcast.Robj2slave(snp4)
      # mpi.bcast.Robj2slave(snp5)
      # mpi.bcast.cmd(eval(assign("snp",rbind(snp1,snp2,snp3,snp4,snp5))))
      # mpi.bcast.cmd(assign("snp",rbind(snp1,snp2,snp3,snp4,snp5)))
      
      snplist=divide_snp_2list(snpdat=snp)
      # mpi.bcast.Robj2slave(snplist) #this doesn't work
      #send each block to slaves
      for (ii in 1:length(snplist))
      {
        tmpsnp=snplist[[ii]]
        mpi.bcast.Robj2slave(tmpsnp)
        mpi.bcast.Robj2slave(ii)
        mpi.remote.exec(assign(paste0("snp",ii),tmpsnp)) #all variables are on slaves!!!
      }
      mpi.bcast.Robj2slave(rbind_snplist)
      mpi.bcast.cmd(assign("snp",rbind_snplist(ii)))
      
      mpi.remote.exec(dim(snp))
      gr_snp=gr_allsnp[idx]
      mpi.bcast.Robj2slave(gr_snp)
      mpi.bcast.Robj2slave(gr_pos)
      mpi.bcast.Robj2slave(phenotype)
     # mpi.bcast.Robj2slave(snp)
      rows=1:nrow(phenotype)
      nchunks=ceiling(length(rows)/n)
      print(paste0("number of total:",nchunks))
      for (i in 1:nchunks)
      {
        cat(i,"..")
        if (i<nchunks)
        {
          seq=rows[((i-1)*n+1):(i*n)]
        }else
        {
          seq=rows[((i-1)*n+1):length(rows)]
        }
        tmp=mpi.parSapply(X=seq,FUN=compute_cor_arow,ncv=ncv,distcutoff=distcutoff,corcutoff=corcutoff,job.num=njobs)
        if (length(unlist(tmp)) %% 7 !=0) print (i)
        res1=matrix(unlist(tmp),ncol=7,byrow = T)
        rownames(res1)=rownames(phenotypepos)[seq]
        res=rbind(res,res1)
      }
      save(chr,res,file=paste0(outfolder,"/TWAStmpresult.RData"))
      Sys.time()
    }
    colnames(res)=c("r2","glmflag","numselectedsnp","numtotalsnp","selectedsnps","selectedsnps_coeff","numlowcorsnp")
    res=as.data.frame(res)
    
    res[,5]=as.character(res[,5])
    res[,6]=as.character(res[,6])
    for (i in c(1:4,7:ncol(res))) res[,i]=as.numeric(as.character(res[,i]))
    return(res)
  }
  
  print("start to build models---")
  Sys.time()
  #rum mpi function and save the result
  res_min=mpi_compute_cor(distcutoff = 5e5)
  save(res_min,file=paste0(outfolder,"/preidiction_michigan_model.RData"))
  Sys.time()
}else
{
  load(paste0(outfolder,"/preidiction_michigan_model.RData"))
}


#extract snps from the prediction models
secondstep=T
if (secondstep==T)
{
  extract_snp2=function(dat=rbind(res_min))
  {
    dat=dat[dat$glmflag==1,]
    snps=unique(unlist(strsplit(dat$selectedsnps,"|",fixed=T)))
    res=data.frame(snp=snps,chr=NA,pos=NA,stringsAsFactors = F)
    
    probenames=rownames(snppos)
    idx=match(res$snp,probenames)
    res$chr=snppos$chr[idx]
    res$pos=snppos$pos[idx]
    idx=order(res$chr,res$pos)
    res=res[idx,]
    res=res[order(res[,2],res[,3]),]
    tmp=paste0(res[,2],"_",res[,3])
    idx=duplicated(tmp) #multi-allel
    res=res[!idx,]
    #create regions file used to extact genotype data
    for (i in 1:length(unique(res$chr)))
    {
      chr=unique(res$chr)[i]
      idx=which(res$chr==chr)
      tmp=ceiling(length(idx)/2)
      chrres=paste0(chr,":",res$pos[idx[1:tmp]],-res$pos[idx[1:tmp]])
      chrres=paste0(chrres,collapse = "\n")
      filename=paste0(outfolder,"/prediction_snps_tabix_chr",chr,"_1.txt")
      fileCon=file(filename)
      writeLines(chrres,fileCon)
      close(fileCon)
      
      chrres=paste0(chr,":",res$pos[idx[(tmp+1):length(idx)]],-res$pos[idx[(tmp+1):length(idx)]])
      chrres=paste0(chrres,collapse = "\n")
      filename=paste0(outfolder,"/prediction_snps_tabix_chr",chr,"_2.txt")
      fileCon=file(filename)
      writeLines(chrres,fileCon)
      close(fileCon)
    }
    return(res)
  }
  
  tmp=extract_snp2()
  print("extract BCA genotypte---")
  Sys.time()
  cmd=paste0("/fh/fast/dai_j/BEACON/BEACON_GRANT/code/bca_extract_genotype2_V8_ambiguousSNP_addnewcontrols_hrc.sh ",prefix)
  system(cmd,wait = T)
  #after run extract_genotype.sh, read the extracted genotype
  print("save BCA genotypte---")
  library(data.table)
  for (i in 1:22)
  {
    cat(i,'..')
    tmp1=fread(paste0(outfolder,"/chr",i,"_select.bim"))
    tmp1=as.data.frame(tmp1)
    tmp=fread(paste0(outfolder,"/chr",i,"_select.raw"),header=T)
    tmp=as.data.frame(tmp)
    idx=duplicated(tmp$IID) #check this
    tmp=tmp[!idx,]
    rownames(tmp)=tmp$IID
    tmp=tmp[,7:ncol(tmp)]
    colnames(tmp)=paste0(tmp1[,1],":",tmp1[,4],"_",tmp1[,5],"_",tmp1[,6])
    if (i==1)
    {
      bcagenotype=tmp
      bcabim=tmp1
    }else
    {
      bcagenotype=cbind.data.frame(bcagenotype,tmp)
      bcabim=rbind(bcabim,tmp1)
    }
  }
  mycolnames=colnames(bcagenotype)
  idx=duplicated(mycolnames)
  bcagenotype=bcagenotype[,!idx]
  bcagenotype=as.data.frame(t(bcagenotype))
  bcabim=bcabim[!idx,]
  colnames(bcagenotype)=gsub("SEP","",colnames(bcagenotype))
  save(bcagenotype,bcabim,file=paste0(outfolder,"/bca_extractgenotype.RData"))
  Sys.time()
}else
{
  load(paste0(outfolder,"/bca_extractgenotype.RData"))
}

thirdstep=T
if (thirdstep==T)
{
  print("predict BCA gene expression---")
  predict_geneexp=function(i=1,modeltable=res_min)
  {
    idx=modeltable$glmflag==1
    #pick the lasso selected genes
    modeltable=modeltable[idx,]
    predicted_geneexp=data.frame(matrix(NA,nrow=1,ncol=2+ncol(bcagenotype_chunk)))
    rownames(predicted_geneexp)=rownames(modeltable)[i]
    colnames(predicted_geneexp)=c("n_totalsnp","n_avaisnp",colnames(bcagenotype_chunk))
    predicted_geneexp[,1]=modeltable$numselectedsnp[i]
    selectedsnps=unlist(strsplit(modeltable$selectedsnps[i],"|",fixed=T))
    selectedcoeff=as.numeric(unlist(strsplit(modeltable$selectedsnps_coeff[i],"|",fixed=T)))
    
    #if some imputed snps need to to flipped
    
    correctedsnps=NULL
    if (length(intersect(selectedsnps,rownames(bcagenotype_chunk)))<length(selectedsnps))
    {
      missingsnps=selectedsnps[!selectedsnps %in% rownames(bcagenotype_chunk)]
      for (j in 1:length(missingsnps))
      {
        tmp=unlist(strsplit(missingsnps[j],"_"))
        tmp1=paste0(tmp[c(1,3,2)],collapse = "_")  #change the order of allele
        idx=which(rownames(bcagenotype_chunk)==tmp1)
        if (length(idx)>0)
        {
          correctedsnps=c(correctedsnps,tmp1)
          idx1=which(selectedsnps==missingsnps[j])
          selectedsnps[idx1]=tmp1 #change the snp name to make it consistent with bca
        }
        
      }
    }
    idx=match(selectedsnps,rownames(bcagenotype_chunk))
    navaisnp=sum(!is.na(idx))
    if (navaisnp>0)
    {
      predicted_geneexp[,2]=navaisnp
      idx=selectedsnps %in% rownames(bcagenotype_chunk)
      selectedsnps=selectedsnps[idx]
      selectedcoeff=selectedcoeff[idx]
      idx1=match(selectedsnps,rownames(bcagenotype_chunk))
      availmat=bcagenotype_chunk[idx1,] #create a small matrix to avoid too large memory usage
      if (length(correctedsnps)>0)
      {
        idx2=match(correctedsnps,rownames(availmat))
        availmat[idx2,]=2-availmat[idx2,]
      }
      geneexp=as.matrix(t(availmat)) %*% selectedcoeff
      predicted_geneexp[,3:ncol(predicted_geneexp)]=geneexp
    }
    return(predicted_geneexp)
  }
  
  ##NOTE: this step requires large nodes. It is not reliable to run on regular nodes (hang frequently)
  ##salloc -t 1-1 --mem-per-cpu 32G -n 21 --partition=largenode mpirun -n 1 R --interactive
  if (!exists("phenotypepos")) load("/fh/fast/dai_j/BEACON/BEACON_GRANT/result/GTExV8blooddata_ambiguous_TPM_addcontrols_for_prediction.RData") #phenotypepos
  if (!exists("res_min")) load(paste0(outfolder,"/preidiction_michigan_model.RData")) #models
  if (!exists("bcagenotype")) load(paste0(outfolder,"/bca_extractgenotype.RData")) #extracted genotype
  # library(Rmpi)
  # njobs=mpi.universe.size() - 1
  # print(njobs)
  # mpi.spawn.Rslaves(nslaves=njobs,needlog = F)
  mpi.bcast.Robj2slave(res_min)
  mpi.bcast.Robj2slave(outfolder)
  #mpi.remote.exec(load(paste0(outfolder,"/bca_extractgenotype.RData")))
  mpi.bcast.Robj2slave(bcabim)
  mpi.bcast.Robj2slave(predict_geneexp)
  #mpi.bcast.Robj2slave(snppos)
  mpi_predict_geneexp=function(modeltable=res_min)
  {
    modeltable=modeltable[modeltable$glmflag==1,]
    rows=1:nrow(modeltable)
    snps_bcagenotype=unlist(strsplit(rownames(bcagenotype),"_"))
    snps_bcagenotype=snps_bcagenotype[seq(1,length(snps_bcagenotype),3)]
    modeltable$cumsumsnp=cumsum(modeltable$numselectedsnp)
    nchunks=ceiling(sum(modeltable$numselectedsnp)/1500) #each chunk picks ~1500 snps
    joblables=cut(modeltable$cumsumsnp,nchunks)
    res=NULL
    # n=njobs
    # nchunks=ceiling(length(rows)/n)
    print(paste0("number of total:",nchunks))
    for (i in 1:nchunks)
    {
      if (i %% 5==0) cat(i,"..")
      #if (i %% 10==0) mpi.remote.exec(gc())
      seq=which(joblables==levels(joblables)[i])
      selectedsnps=unique(unlist(strsplit(modeltable$selectedsnps[seq],"|",fixed=T)))
      snps_selectedsnps=unlist(strsplit(selectedsnps,"_"))
      snps_selectedsnps=snps_selectedsnps[seq(1,length(snps_selectedsnps),3)]
      idx=snps_bcagenotype %in% snps_selectedsnps #extract genotypes for each chunk (use chr:pos)
      bcagenotype_chunk=bcagenotype[idx,]
      mpi.bcast.Robj2slave(bcagenotype_chunk)
      tmp=mpi.parSapply(X=seq,FUN=predict_geneexp,modeltable=modeltable,job.num=min(c(njobs,length(seq))))
      res1=as.data.frame(matrix(unlist(tmp),ncol=2+ncol(bcagenotype),byrow = T))
      if (length(unlist(tmp)) %% (2+ncol(bcagenotype)) !=0) stop(i)
      res=rbind(res,res1)
    }
    res=as.data.frame(res)
    rownames(res)=rownames(modeltable)
    colnames(res)=c("n_totalsnp","n_avaisnp",colnames(bcagenotype))
    return(res)
  }
  predict_min=mpi_predict_geneexp()
  #predict_1se=mpi_predict_geneexp(modeltable=res_1se)
  save(predict_min,file=paste0(outfolder,"/bca_predict_geneexp.RData"))
  Sys.time()
}else
{
  load(paste0(outfolder,"/bca_predict_geneexp.RData"))
}


#step2 association---
print("start association analysis---")
library(readxl)

sampletable=readxl::read_excel("/fh/fast/dai_j/BEACON/BEACON_GRANT/data/PLINKinputCombo_bca_07Feb2018.xls",1)
# geneexpsamplenames=strsplit(colnames(predict_min)[3:ncol(predict_min)],"_") #use localid
# geneexpsamplenames=sapply(1:length(geneexpsamplenames),function(x){
#   tmp=geneexpsamplenames[[x]]
#   paste0(tmp[2:length(tmp)],collapse = "_")
# })

for (i in 1:ncol(sampletable))
{
  idx=which(sampletable[,i]==-9)
  if (length(idx)>0)
    sampletable[idx,i]=NA
}

#add covariate table (pc1-pc4)
readeigenstrat=function(eigfile="/fh/fast/dai_j/BEACON/BEACON_GRANT/result/imputation_vcf/merge_beacon_cambridge_genotype.pca",
                        eigsampfile="/fh/fast/dai_j/BEACON/BEACON_GRANT/result/imputation_vcf/merge_beacon_cambridge_genotype.pedind",
                        nskip=16)
{
  eigsamples=read.table(eigsampfile,stringsAsFactors = F)
  tmp=read.table(eigfile,skip=nskip,stringsAsFactors = F)
  colnames(tmp)=paste0("pc",1:ncol(tmp))
  rownames(tmp)=eigsamples$V2
  tmp$sex="M"
  tmp$sex[eigsamples$V5==2]="F"
  return(tmp)
}

covariatetable=readeigenstrat()
rownames(covariatetable)=gsub("SEP","",rownames(covariatetable))
all(colnames(predict_min)[3:ncol(predict_min)] %in% rownames(covariatetable))
#add case/control
tmp=covariatetable
tmp$phenoBE_bca=tmp$phenoEA_bca=tmp$phenoEABE_bca=1
comsamples=intersect(sampletable$localid,rownames(tmp))
idx1=match(comsamples,rownames(tmp))
idx2=match(comsamples,sampletable$localid)
tmp$phenoBE_bca[idx1]=sampletable$phenoBE_bca[idx2]
tmp$phenoEA_bca[idx1]=sampletable$phenoEA_bca[idx2]
tmp$phenoEABE_bca[idx1]=sampletable$phenoEABE_bca[idx2]
tmp$phenoBE_bca[tmp$phenoBE_bca==-9]=NA
tmp$phenoEA_bca[tmp$phenoEA_bca==-9]=NA
tmp$phenoEABE_bca[tmp$phenoEABE_bca==-9]=NA
covariatetable=tmp
covariatetable$sex=factor(covariatetable$sex)

# pvalue_arow=function(i,idx1,idx2)
# {
#   y=c(rep(1,length(idx1)),rep(0,length(idx2)))
#   x=as.numeric(predict_bcageneexp[i,c(idx1,idx2)])
#   BE_p=NA
#   if (sum(is.na(x))<0.6*length(x))
#   {
#     #fm=glm(y~x+age+sex+pc1+pc2+pc3+pc4,data=covariates,family=binomial)
#     fm=glm(y~x+pc1+pc2+pc3+pc4+sex,data=covariates,family=binomial)
#     #fm=glm(y~x+age+sex+site1+pc1+pc2+pc3,data=covariates,family=binomial) #including site
#     tmp=summary(fm)$coefficients
#     if ("x" %in% rownames(tmp))
#     {
#       BE_p=summary(fm)$coefficients[2,4]
#     }
#   }
#   return(BE_p)
# }

pvalue_arow=function(i,idx1,idx2)
{
  y=c(rep(1,length(idx1)),rep(0,length(idx2)))
  x=as.numeric(predict_bcageneexp[i,c(idx1,idx2)])
  BE_p=NA
  if (sum(is.na(x))<0.6*length(x))
  {
    #fm=glm(y~x+age+sex+pc1+pc2+pc3+pc4,data=covariates,family=binomial)
    fm=glm(y~x+pc1+pc2+pc3+pc4+pc5+pc6+sex,data=covariates,family=binomial)
    #fm=glm(y~x+age+sex+site1+pc1+pc2+pc3,data=covariates,family=binomial) #including site
    tmp=summary(fm)$coefficients
    if ("x" %in% rownames(tmp))
    {
      BE_p=summary(fm)$coefficients[2,4]
    }
  }
  return(BE_p)
}


qqplot=function(pvalue=NULL,main="",xlim=NULL,ylim=NULL)
{
  n=length(pvalue)
  plot(-log((1:n)/n,base=10),-log(pvalue[order(pvalue)],base=10),xlab="Expected p-value (log10)",
       ylab="Observed p-value (log10)",main=main,xlim=xlim,ylim=ylim,cex.lab=1.3,cex.axis=1.3)
  abline(0,1,lty=2)
}

if (!exists("predict_min")) load(paste0(outfolder,"/bca_predict_geneexp.RData"))

# mpi_association=function(predict_bcageneexp=predict_min)
# {
#   predict_bcageneexp=predict_bcageneexp[,3:ncol(predict_bcageneexp)]
#   geneexpsamplenames=colnames(predict_bcageneexp)
#   geneexpsamplenames=intersect(rownames(covariatetable),geneexpsamplenames)
#   idx=match(geneexpsamplenames,colnames(predict_bcageneexp))
#   all_predict_bcageneexp=predict_bcageneexp=predict_bcageneexp[,idx]
#   idx=match(geneexpsamplenames,rownames(covariatetable))
#   covariatetable1=covariatetable[idx,]
#   #BE
#   mpi.bcast.Robj2slave(pvalue_arow)
#   #mpi.bcast.Robj2slave(recodesite)
#   #mpi.bcast.Robj2slave(predict_bcageneexp)
#   mpi.bcast.Robj2slave(covariatetable1)
#   idx1=which(covariatetable1$phenoBE_bca==2) #case
#   length(idx1) #3288
#   idx2=which(covariatetable1$phenoBE_bca==1)
#   length(idx2) #3195
#   covariates=data.frame(pc1=covariatetable1$pc1[c(idx1,idx2)],pc2=covariatetable1$pc2[c(idx1,idx2)],pc3=covariatetable1$pc3[c(idx1,idx2)],pc4=covariatetable1$pc4[c(idx1,idx2)],
#                         sex=covariatetable1$sex[c(idx1,idx2)],stringsAsFactors = F)
#   #covariates=recodesite(covariates1=covariates,idx1=idx1,idx2=idx2)
#   mpi.bcast.Robj2slave(idx1)
#   mpi.bcast.Robj2slave(idx2)
#   mpi.bcast.Robj2slave(covariates)
#   n=1000 #1000 snps one time
#   rows=1:nrow(all_predict_bcageneexp)
#   nchunks=ceiling(nrow(all_predict_bcageneexp)/n)
#   print(paste0("BE:number of total:",nchunks))
#   BE_p=NULL
#   for (i in 1:nchunks)
#   {
#     cat(i,"..")
#     if (i<nchunks)
#     {
#       seq=rows[((i-1)*n+1):(i*n)]
#     }else
#     {
#       seq=rows[((i-1)*n+1):length(rows)]
#     }
#     predict_bcageneexp=all_predict_bcageneexp[seq,]
#     mpi.bcast.Robj2slave(predict_bcageneexp)
#     seq=1:nrow(predict_bcageneexp)
#     tmp=mpi.parSapply(X=seq,FUN=pvalue_arow,idx1=idx1,idx2=idx2,job.num=njobs)
#     BE_p=c(BE_p,tmp)
#   }
#   
#   
#   #EA
#   idx1=which(covariatetable1$phenoEA_bca==2) #case
#   length(idx1) #2514
#   idx2=which(covariatetable1$phenoEA_bca==1)
#   length(idx2) #3198
#   covariates=data.frame(pc1=covariatetable1$pc1[c(idx1,idx2)],pc2=covariatetable1$pc2[c(idx1,idx2)],pc3=covariatetable1$pc3[c(idx1,idx2)],pc4=covariatetable1$pc4[c(idx1,idx2)],
#                         sex=covariatetable1$sex[c(idx1,idx2)],stringsAsFactors = F)
#   #covariates=recodesite(covariates1=covariates,idx1=idx1,idx2=idx2)
#   mpi.bcast.Robj2slave(idx1)
#   mpi.bcast.Robj2slave(idx2)
#   mpi.bcast.Robj2slave(covariates)
#   print(paste0("EA:number of total:",nchunks))
#   EA_p=NULL
#   for (i in 1:nchunks)
#   {
#     cat(i,"..")
#     if (i<nchunks)
#     {
#       seq=rows[((i-1)*n+1):(i*n)]
#     }else
#     {
#       seq=rows[((i-1)*n+1):length(rows)]
#     }
#     predict_bcageneexp=all_predict_bcageneexp[seq,]
#     mpi.bcast.Robj2slave(predict_bcageneexp)
#     seq=1:nrow(predict_bcageneexp)
#     tmp=mpi.parSapply(X=seq,FUN=pvalue_arow,idx1=idx1,idx2=idx2,job.num=njobs)
#     EA_p=c(EA_p,tmp)
#   }
#   
#   #EA vs # BE
#   idx1=which(covariatetable1$phenoEA_bca==2) # EAcase
#   length(idx1) #2514
#   idx2=which(covariatetable1$phenoBE_bca==2) #BEcase
#   length(idx2) #3288
#   length(intersect(idx1,idx2))
#   covariates=data.frame(pc1=covariatetable1$pc1[c(idx1,idx2)],pc2=covariatetable1$pc2[c(idx1,idx2)],pc3=covariatetable1$pc3[c(idx1,idx2)],pc4=covariatetable1$pc4[c(idx1,idx2)],
#                         sex=covariatetable1$sex[c(idx1,idx2)],stringsAsFactors = F)
#   #covariates=recodesite(covariates1=covariates,idx1=idx1,idx2=idx2)
#   mpi.bcast.Robj2slave(idx1)
#   mpi.bcast.Robj2slave(idx2)
#   mpi.bcast.Robj2slave(covariates)
#   print(paste0("BEA:number of total:",nchunks))
#   BEA_p=NULL
#   for (i in 1:nchunks)
#   {
#     cat(i,"..")
#     if (i<nchunks)
#     {
#       seq=rows[((i-1)*n+1):(i*n)]
#     }else
#     {
#       seq=rows[((i-1)*n+1):length(rows)]
#     }
#     predict_bcageneexp=all_predict_bcageneexp[seq,]
#     mpi.bcast.Robj2slave(predict_bcageneexp)
#     seq=1:nrow(predict_bcageneexp)
#     tmp=mpi.parSapply(X=seq,FUN=pvalue_arow,idx1=idx1,idx2=idx2,job.num=njobs)
#     BEA_p=c(BEA_p,tmp)
#   }
#   
#   #EA and BE vs control
#   idx1=which(covariatetable1$phenoBE_bca==2 | covariatetable1$phenoEA_bca==2) #BE or EAcase
#   length(idx1) #5802
#   idx2=which(covariatetable1$phenoBE_bca==1 |covariatetable1$phenoEA_bca==1) #Control
#   length(idx2) #3198
#   length(intersect(idx1,idx2))
#   covariates=data.frame(pc1=covariatetable1$pc1[c(idx1,idx2)],pc2=covariatetable1$pc2[c(idx1,idx2)],pc3=covariatetable1$pc3[c(idx1,idx2)],pc4=covariatetable1$pc4[c(idx1,idx2)],
#                         sex=covariatetable1$sex[c(idx1,idx2)],stringsAsFactors = F)
#   #covariates=recodesite(covariates1=covariates,idx1=idx1,idx2=idx2)
#   mpi.bcast.Robj2slave(idx1)
#   mpi.bcast.Robj2slave(idx2)
#   mpi.bcast.Robj2slave(covariates)
#   print(paste0("BEEA:number of total:",nchunks))
#   BEEA_p=NULL
#   for (i in 1:nchunks)
#   {
#     cat(i,"..")
#     if (i<nchunks)
#     {
#       seq=rows[((i-1)*n+1):(i*n)]
#     }else
#     {
#       seq=rows[((i-1)*n+1):length(rows)]
#     }
#     predict_bcageneexp=all_predict_bcageneexp[seq,]
#     mpi.bcast.Robj2slave(predict_bcageneexp)
#     seq=1:nrow(predict_bcageneexp)
#     tmp=mpi.parSapply(X=seq,FUN=pvalue_arow,idx1=idx1,idx2=idx2,job.num=njobs)
#     BEEA_p=c(BEEA_p,tmp)
#   }
#   
#   res=data.frame(BE_p=BE_p,BE_fdr=p.adjust(BE_p),EA_p=EA_p,EA_fdr=p.adjust(EA_p),BEA_p=BEA_p,BEA_fdr=p.adjust(BEA_p),BEEA_p=BEEA_p,BEEA_fdr=p.adjust(BEEA_p))
#   rownames(res)=rownames(all_predict_bcageneexp)
#   return(res)
# }

#6 pcs
mpi_association=function(predict_bcageneexp=predict_min)
{
  predict_bcageneexp=predict_bcageneexp[,3:ncol(predict_bcageneexp)]
  geneexpsamplenames=colnames(predict_bcageneexp)
  geneexpsamplenames=intersect(rownames(covariatetable),geneexpsamplenames)
  idx=match(geneexpsamplenames,colnames(predict_bcageneexp))
  all_predict_bcageneexp=predict_bcageneexp=predict_bcageneexp[,idx]
  idx=match(geneexpsamplenames,rownames(covariatetable))
  covariatetable1=covariatetable[idx,]
  #BE
  mpi.bcast.Robj2slave(pvalue_arow)
  #mpi.bcast.Robj2slave(recodesite)
  #mpi.bcast.Robj2slave(predict_bcageneexp)
  mpi.bcast.Robj2slave(covariatetable1)
  idx1=which(covariatetable1$phenoBE_bca==2) #case
  length(idx1) #3288
  idx2=which(covariatetable1$phenoBE_bca==1)
  length(idx2) #3195
  covariates=data.frame(pc1=covariatetable1$pc1[c(idx1,idx2)],pc2=covariatetable1$pc2[c(idx1,idx2)],pc3=covariatetable1$pc3[c(idx1,idx2)],pc4=covariatetable1$pc4[c(idx1,idx2)],
                        pc5=covariatetable1$pc5[c(idx1,idx2)],pc6=covariatetable1$pc6[c(idx1,idx2)],sex=covariatetable1$sex[c(idx1,idx2)],stringsAsFactors = F)
  #covariates=recodesite(covariates1=covariates,idx1=idx1,idx2=idx2)
  mpi.bcast.Robj2slave(idx1)
  mpi.bcast.Robj2slave(idx2)
  mpi.bcast.Robj2slave(covariates)
  n=1000 #1000 snps one time
  rows=1:nrow(all_predict_bcageneexp)
  nchunks=ceiling(nrow(all_predict_bcageneexp)/n)
  print(paste0("BE:number of total:",nchunks))
  BE_p=NULL
  for (i in 1:nchunks)
  {
    cat(i,"..")
    if (i<nchunks)
    {
      seq=rows[((i-1)*n+1):(i*n)]
    }else
    {
      seq=rows[((i-1)*n+1):length(rows)]
    }
    predict_bcageneexp=all_predict_bcageneexp[seq,]
    mpi.bcast.Robj2slave(predict_bcageneexp)
    seq=1:nrow(predict_bcageneexp)
    tmp=mpi.parSapply(X=seq,FUN=pvalue_arow,idx1=idx1,idx2=idx2,job.num=njobs)
    BE_p=c(BE_p,tmp)
  }
  
  
  #EA
  idx1=which(covariatetable1$phenoEA_bca==2) #case
  length(idx1) #2514
  idx2=which(covariatetable1$phenoEA_bca==1)
  length(idx2) #3198
  covariates=data.frame(pc1=covariatetable1$pc1[c(idx1,idx2)],pc2=covariatetable1$pc2[c(idx1,idx2)],pc3=covariatetable1$pc3[c(idx1,idx2)],pc4=covariatetable1$pc4[c(idx1,idx2)],
                        pc5=covariatetable1$pc5[c(idx1,idx2)],pc6=covariatetable1$pc6[c(idx1,idx2)],sex=covariatetable1$sex[c(idx1,idx2)],stringsAsFactors = F)
  #covariates=recodesite(covariates1=covariates,idx1=idx1,idx2=idx2)
  mpi.bcast.Robj2slave(idx1)
  mpi.bcast.Robj2slave(idx2)
  mpi.bcast.Robj2slave(covariates)
  print(paste0("EA:number of total:",nchunks))
  EA_p=NULL
  for (i in 1:nchunks)
  {
    cat(i,"..")
    if (i<nchunks)
    {
      seq=rows[((i-1)*n+1):(i*n)]
    }else
    {
      seq=rows[((i-1)*n+1):length(rows)]
    }
    predict_bcageneexp=all_predict_bcageneexp[seq,]
    mpi.bcast.Robj2slave(predict_bcageneexp)
    seq=1:nrow(predict_bcageneexp)
    tmp=mpi.parSapply(X=seq,FUN=pvalue_arow,idx1=idx1,idx2=idx2,job.num=njobs)
    EA_p=c(EA_p,tmp)
  }
  
  #EA vs # BE
  idx1=which(covariatetable1$phenoEA_bca==2) # EAcase
  length(idx1) #2514
  idx2=which(covariatetable1$phenoBE_bca==2) #BEcase
  length(idx2) #3288
  length(intersect(idx1,idx2))
  covariates=data.frame(pc1=covariatetable1$pc1[c(idx1,idx2)],pc2=covariatetable1$pc2[c(idx1,idx2)],pc3=covariatetable1$pc3[c(idx1,idx2)],pc4=covariatetable1$pc4[c(idx1,idx2)],
                        pc5=covariatetable1$pc5[c(idx1,idx2)],pc6=covariatetable1$pc6[c(idx1,idx2)],sex=covariatetable1$sex[c(idx1,idx2)],stringsAsFactors = F)
  #covariates=recodesite(covariates1=covariates,idx1=idx1,idx2=idx2)
  mpi.bcast.Robj2slave(idx1)
  mpi.bcast.Robj2slave(idx2)
  mpi.bcast.Robj2slave(covariates)
  print(paste0("BEA:number of total:",nchunks))
  BEA_p=NULL
  for (i in 1:nchunks)
  {
    cat(i,"..")
    if (i<nchunks)
    {
      seq=rows[((i-1)*n+1):(i*n)]
    }else
    {
      seq=rows[((i-1)*n+1):length(rows)]
    }
    predict_bcageneexp=all_predict_bcageneexp[seq,]
    mpi.bcast.Robj2slave(predict_bcageneexp)
    seq=1:nrow(predict_bcageneexp)
    tmp=mpi.parSapply(X=seq,FUN=pvalue_arow,idx1=idx1,idx2=idx2,job.num=njobs)
    BEA_p=c(BEA_p,tmp)
  }
  
  #EA and BE vs control
  idx1=which(covariatetable1$phenoBE_bca==2 | covariatetable1$phenoEA_bca==2) #BE or EAcase
  length(idx1) #5802
  idx2=which(covariatetable1$phenoBE_bca==1 |covariatetable1$phenoEA_bca==1) #Control
  length(idx2) #3198
  length(intersect(idx1,idx2))
  covariates=data.frame(pc1=covariatetable1$pc1[c(idx1,idx2)],pc2=covariatetable1$pc2[c(idx1,idx2)],pc3=covariatetable1$pc3[c(idx1,idx2)],pc4=covariatetable1$pc4[c(idx1,idx2)],
                        pc5=covariatetable1$pc5[c(idx1,idx2)],pc6=covariatetable1$pc6[c(idx1,idx2)],sex=covariatetable1$sex[c(idx1,idx2)],stringsAsFactors = F)
  #covariates=recodesite(covariates1=covariates,idx1=idx1,idx2=idx2)
  mpi.bcast.Robj2slave(idx1)
  mpi.bcast.Robj2slave(idx2)
  mpi.bcast.Robj2slave(covariates)
  print(paste0("BEEA:number of total:",nchunks))
  BEEA_p=NULL
  for (i in 1:nchunks)
  {
    cat(i,"..")
    if (i<nchunks)
    {
      seq=rows[((i-1)*n+1):(i*n)]
    }else
    {
      seq=rows[((i-1)*n+1):length(rows)]
    }
    predict_bcageneexp=all_predict_bcageneexp[seq,]
    mpi.bcast.Robj2slave(predict_bcageneexp)
    seq=1:nrow(predict_bcageneexp)
    tmp=mpi.parSapply(X=seq,FUN=pvalue_arow,idx1=idx1,idx2=idx2,job.num=njobs)
    BEEA_p=c(BEEA_p,tmp)
  }
  
  res=data.frame(BE_p=BE_p,BE_fdr=p.adjust(BE_p),EA_p=EA_p,EA_fdr=p.adjust(EA_p),BEA_p=BEA_p,BEA_fdr=p.adjust(BEA_p),BEEA_p=BEEA_p,BEEA_fdr=p.adjust(BEEA_p))
  rownames(res)=rownames(all_predict_bcageneexp)
  return(res)
}
#load the old result assoc_min
#load(paste0(outfolder,"/bca_assoc.RData"))
assoc_min_pc6=mpi_association()
#assoc_1se=mpi_association(predict_bcageneexp = predict_1se)
save(assoc_min_pc6,file=paste0(outfolder,"/bca_assoc.RData"))
load(paste0(outfolder,"/bca_assoc.RData"))
# quantile(assoc_min[,1],na.rm=T)
# quantile(assoc_min[,3],na.rm=T)
# quantile(assoc_min[,5],na.rm=T)
# quantile(assoc_min[,7],na.rm=T)
quantile(assoc_min_pc6[,1],na.rm=T)
quantile(assoc_min_pc6[,3],na.rm=T)
quantile(assoc_min_pc6[,5],na.rm=T)
quantile(assoc_min_pc6[,7],na.rm=T)
Sys.time()
print("Done")
sink(type = "message")
sink(type = "output")
## quit program
mpi.close.Rslaves()
mpi.quit()
quit()

# qqplot=function(pvalue=NULL,fwer=NULL,main="",xlim=NULL,ylim=NULL)
# {
#   n=length(pvalue)
#   plot(-log((1:n)/n,base=10),-log(pvalue[order(pvalue)],base=10),xlab="Expected p-value (-log base 10)",
#        ylab="Observed p-value (-log base 10)",main=main,xlim=xlim,ylim=ylim,cex.lab=1.3,cex.axis=1.3)
#   abline(0,1,lty=2)
#   pvalue_order=pvalue[order(pvalue)]
#   if (is.null(fwer))
#   {
#     fwer=p.adjust(pvalue_order,method="bonferroni")
#     idx=which(fwer<0.05)
#     if (length(idx)>0)
#     {
#       points(-log((1:n)/n,base=10)[idx],-log(pvalue[order(pvalue)],base=10)[idx],pch=16,col="red")
#       print(paste0("#FWER<0.05:",length(idx)))
#       legend("topleft",legend = "FWER<0.05",pch=16,col="red")
#     }
#   }else
#   {
#     idx1=sum(fwer<0.05)
#     if (length(idx1)>0)
#     {
#       idx=1:idx1
#       points(-log((1:n)/n,base=10)[idx],-log(pvalue[order(pvalue)],base=10)[idx],pch=16,col="red")
#       print(paste0("#FWER<0.05:",length(idx)))
#       legend("topleft",legend = "FWER<0.05",pch=16,col="red")
#     }
#   }
# }
# load("/fh/fast/dai_j/BEACON/BEACON_GRANT/data/gtexv8_ge_anno.RData")
# proteingenes=unique(gtexv8_ge_anno$Symbol[gtexv8_ge_anno$gene_type=="protein_coding"])
# assoc_min_code=assoc_min[rownames(assoc_min) %in% proteingenes,]
# qqplot_twas=function()
# {
#   par(mar=c(6,6,2,1))
#   par(mfrow=c(2,2))
#   qqplot(assoc_min_code$BE_p)
#   qqplot(assoc_min_code$EA_p)
#   qqplot(assoc_min_code$BEA_p)
#   qqplot(assoc_min_code$BEEA_p)
# }